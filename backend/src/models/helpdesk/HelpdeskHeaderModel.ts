import prisma from "../../PrismaConnection";
import { HelpdeskHeader } from "../../../generated/prisma";
import HelpdeskDetailsModel from "./HelpdeskDetails";
import HelpdeskCcModel from "./HelpdeskCc";
import HelpdeskNoteModel from "./HelpdeskNote";
import crypto from "crypto";
import path from "path";
import fs from "fs";
import { Prisma } from "@prisma/client";
import HelpdeskNoteJobRegModel from "./HelpdeskNoteJobReg";

// HelpdeskHeaderModel class is used for encapsulating Helpdesk Header properties with all of its method for creating, updating or retrieving data from database. 
// It is created based on HelpdeskHeader table structure in database and to align with the type created by Prisma ORM, with some additional properties outside of 
// existing properties / columns from database table to support the needs of application.  
class HelpdeskHeaderModel {
  nomor: string;
  readonly title: string;
  readonly tipe: string;
  readonly prioritas: string;
  readonly dari: string;
  readonly kepada: string;
  status: string;
  pertimbangan: string = "";
  readonly tanggalTerbit: Date;
  tanggalTerima: Date = new Date("1900-01-01");
  tanggalSelesai: Date = new Date("1900-01-01");
  hashedFile: string = "";
  namaFile: string = "";
  namaFileKepada: string = "";
  progress: string = "";
  notified: boolean = false;
  readonly detailsList: Array<HelpdeskDetailsModel> = [];
  readonly ccList: Array<HelpdeskCcModel> = [];
  readonly noteList: Array<HelpdeskNoteModel> = [];

  // Constructor of the Helpdesk Header class
  constructor(nomor: string, title: string, tipe: string, prioritas: string, dari: string, kepada: string, tanggalTerbit: Date, status: string) {
    this.nomor = nomor;
    this.title = title;
    this.tipe = tipe;
    this.prioritas = prioritas;
    this.dari = dari;
    this.kepada = kepada;
    this.tanggalTerbit = tanggalTerbit;
    this.status = status;
  };

  // Secondary constructor of Helpdesk Header class by providing HelpdeskHeader type value for its parameter
  static createFromType(helpdesk: HelpdeskHeader) {
    const helpdeskHeader = new HelpdeskHeaderModel(helpdesk.Nomor, helpdesk.Title, helpdesk.Tipe, helpdesk.Prioritas, helpdesk.Dari, helpdesk.Kepada, helpdesk.TanggalTerbit, helpdesk.Status);
    helpdeskHeader.pertimbangan = helpdesk.Pertimbangan;
    helpdeskHeader.tanggalTerima = helpdesk.TanggalTerima;
    helpdeskHeader.tanggalSelesai = helpdesk.TanggalSelesai;
    helpdeskHeader.namaFile = helpdesk.NamaFile;
    helpdeskHeader.namaFileKepada = helpdesk.NamaFileKepada;
    return helpdeskHeader;
  };

  // Method for converting current HelpdeskHeader instance to HelpdeskHeader type generated by Prisma ORM
  createAsType = () => {
    const data: HelpdeskHeader = {
      Nomor: this.nomor,
      Title: this.title,
      Tipe: this.tipe,
      Prioritas: this.prioritas,
      Dari: this.dari,
      Kepada: this.kepada,
      Status: this.status,
      Pertimbangan: this.pertimbangan,
      TanggalTerbit: this.tanggalTerbit,
      TanggalTerima: this.tanggalTerima,
      TanggalSelesai: this.tanggalSelesai,
      NamaFile: this.namaFile,
      NamaFileKepada: this.namaFileKepada
    }
    return data;
  };

  // Method for generating new number for new Helpdesk by taking the latest number of the latest published helpdesk from the same division or department 
  // and on the same year.
  static async generateLatestNumber(bagian: string) {
    let prefixNumber = `${bagian}-${new Date().getFullYear()}-`;
    const latestNumber = await prisma.helpdeskHeader.aggregate({
      _max: { Nomor: true },
      where: { Nomor: { startsWith: prefixNumber } }
    });
    prefixNumber = prefixNumber.concat((latestNumber._max.Nomor !== null ? Number(latestNumber._max.Nomor.split("-")[2]) + 1 : 1).toString().padStart(4, '0'));
    return prefixNumber;
  };

  // Method to retrieve other applications notifications by executing the table-value function prepared before. The function also returns counter for
  // several helpdesk header catogories that needs current logged in user's action.
  static async getNotificationList(user: string) {
    const query: any[] = await prisma.$queryRaw`SELECT * FROM [dbo].[EF_GET_NOTIF](${user})`;
    const result: { tipe: string, jumlah: number }[] = [];
    query.forEach(line => result.push({ tipe: line.TIPE, jumlah: line.JUMLAH }));
    return result;
  };

  // Method to retrive a list of Helpdesk Header data based on client's logged in user account and type of Helpdesk Header category requested by client.
  static async getHelpdeskListBySelection(user: string, type: string) {
    let whereClause = "";
    let orderClause = "T0.TanggalTerbit DESC";
    switch (type) {
			case "all":
				whereClause = `SUBSTRING(T0.Nomor, 1, 4) = SUBSTRING('${user}', 1, 4) AND (T0.Dari = '${user}' OR SUBSTRING('${user}', 5, 3) = '-01')`;
				break;
			case "created":
				whereClause = `T0.Dari = '${user}'`;
				break;
      case "unpublished":
        whereClause = `(CONCAT(T2.CC, '-01') = '${user}' OR (T2.CC = '${user}' AND (SUBSTRING('${user}', 1, 4) IN ('JPJL','MSSA','MWGM') OR '${user}' LIKE '%PBL%')) OR CONCAT(T0.Kepada, '-01') = '${user}') AND T0.[Status] = 'UNPUBLISHED'`;
        break;
			case "approved":
				whereClause = `((CONCAT(T2.CC, '-01') = '${user}' OR (T2.CC = '${user}' AND (SUBSTRING('${user}', 1, 4) IN ('JPJL','MSSA','MWGM') OR '${user}' LIKE '%PBL%'))) AND T2.AC IN ('APPROVE','REVISION')) OR (CONCAT(T0.Kepada, '-01') = '${user}' AND (SELECT COUNT(A.LineNum) FROM HelpdeskDetails A WHERE A.Nomor = T0.Nomor AND ISNULL(A.PIC, '') <> '') > 0)`;
				break;
			case "revision":
				whereClause = `(((CONCAT(T2.CC, '-01') = '${user}' OR (T2.CC = '${user}' AND (SUBSTRING('${user}', 1, 4) IN ('JPJL','MSSA','MWGM') OR '${user}' LIKE '%PBL%'))) AND T2.AC <> 'APPROVE' AND (SELECT COUNT(X.CC) FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.LineNum < T2.LineNum AND X.AC <> 'APPROVE') <= 0) OR (CONCAT(T0.Kepada, '-01') = '${user}' AND (SELECT COUNT(X.CC) FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC <> 'APPROVE') <= 0)) AND T0.[Status] = 'REVISION'`;
				break;
			case "rejected":
				whereClause = `(((CONCAT(T2.CC, '-01') = '${user}' OR (T2.CC = '${user}' AND (SUBSTRING('${user}', 1, 4) IN ('JPJL','MSSA','MWGM') OR '${user}' LIKE '%PBL%'))) AND (SELECT COUNT(X.CC) FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.LineNum < T2.LineNum AND X.AC <> 'APPROVE') <= 0) OR (CONCAT(T0.Kepada, '-01') = '${user}' AND (SELECT COUNT(X.CC) FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC <> 'APPROVE') <= 0)) AND T0.[Status] = 'REJECTED'`;
				break;
			case "waiting-for-approval":
				whereClause = `(CONCAT(T2.CC, '-01') = '${user}' OR (T2.CC = '${user}' AND (SUBSTRING('${user}', 1, 4) IN ('JPJL','MSSA','MWGM') OR '${user}' LIKE '%PBL%'))) AND T2.AC <> 'APPROVE' AND (SELECT COUNT(X.CC) FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.LineNum < T2.LineNum AND X.AC <> 'APPROVE') <= 0 AND T0.[Status] NOT IN ('DONE','REJECTED','REVISION')`;
				break;
      case "waiting-for-review":
        whereClause = `T2.AC = 'REQUESTING REVIEW' AND '${user}' IN (SELECT CASE WHEN LEN(item) = 4 THEN CONCAT(item, '-01') ELSE item END item FROM [dbo].[ufnSplt](T4.Mentions, ','))`;
        break;
			case "approval-request":
				whereClause = `CONCAT(T0.Kepada, '-01') = '${user}' AND (SELECT COUNT(A.LineNum) FROM HelpdeskCc A WHERE A.Nomor = T0.Nomor AND A.AC <> 'APPROVE') <= 0 AND ISNULL(T1.PIC, '') = '' AND T0.[Status] NOT IN ('DONE','REJECTED','REVISION')`;
				break;
			case "job-registration":
				whereClause = `((T1.PIC = '${user}' OR (CONCAT(T0.Kepada, '-01') = '${user}' AND ISNULL(T1.PIC, '') <> '')) OR T2.PIC = '${user}') AND T0.[Status] NOT IN ('DONE', 'REJECTED','REVISION')`;
        orderClause = "CASE WHEN T0.[Status] = 'PUBLISHED' THEN 0 WHEN T0.[Status] = 'UNPUBLISHED' THEN 1 ELSE 2 END"
				break;
      case "done":
        whereClause = `(T0.Dari = '${user}' OR CONCAT(T0.Kepada, '-01') = '${user}' OR T1.PIC = '${user}' OR CONCAT(T2.CC, '-01') = '${user}' OR T2.PIC = '${user}') AND T0.[Status] = 'DONE'`
        break;
			default:
				whereClause = `SUBSTRING(T0.Nomor, 1, 4) = SUBSTRING('${user}', 1, 4) AND (T0.Dari = '${user}' OR SUBSTRING('${user}', 5, 3) = '-01')`;
				break;
		}

    const helpdeskList: HelpdeskHeader[] = await prisma.$queryRawUnsafe(`SELECT DISTINCT T0.Nomor, CAST(T0.Title AS VARCHAR(MAX)) Title, T0.Tipe, T0.Prioritas, T0.Dari, CONCAT(T0.Kepada, ' - ', T3.Descrption) Kepada, T0.TanggalTerbit, T0.[Status], CASE WHEN T0.[Status] = 'DONE' THEN 'Finished (Done)' WHEN T0.[Status] = 'REJECTED' THEN 'Rejected' WHEN T0.[Status] = 'REVISION' THEN CASE WHEN ISNULL((SELECT X.CC FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC = 'REVISION'), '') = '' THEN CONCAT('Revision was asked by recipient (', CONCAT(T0.Kepada, ' - ', T3.Descrption), ')') ELSE (SELECT CONCAT('Revision was asked by Approver ', X.LineNum + 1, ' (', X.CC, ')') FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC = 'REVISION') END WHEN T0.[Status] = 'UNPUBLISHED' THEN (SELECT CONCAT('Waiting for Approval from Approver ', X.LineNum + 1, ' (', X.CC, ')') FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC = 'NO ACTION' AND (SELECT COUNT(Y.CC) FROM HelpdeskCc Y WHERE Y.Nomor = X.Nomor AND Y.LineNum < X.LineNum AND Y.AC <> 'APPROVE') <= 0) WHEN T0.[Status] = 'PUBLISHED' THEN CONCAT('Processing request by recipient (', CONCAT(T0.Kepada, ' - ', T3.Descrption), ')') ELSE '' END Pertimbangan, CASE WHEN T0.[Status] = 'REVISION' AND T0.Dari = '${user}' THEN 'Y' WHEN T0.[Status] = 'UNPUBLISHED' AND CONCAT((SELECT X.CC FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC = 'NO ACTION' AND (SELECT COUNT(Y.CC) FROM HelpdeskCc Y WHERE Y.Nomor = X.Nomor AND Y.LineNum < X.LineNum AND Y.AC <> 'APPROVE') <= 0), '-01') = '${user}' THEN 'Y' WHEN T0.[Status] = 'UNPUBLISHED' AND (SELECT X.AC FROM HelpdeskCc X WHERE X.Nomor = T0.Nomor AND X.AC = '${user}' AND (SELECT COUNT(Y.CC) FROM HelpdeskCc Y WHERE Y.Nomor = X.Nomor AND Y.LineNum < X.LineNum AND Y.AC <> 'APPROVE') <= 0) = '${user}' THEN 'Y' WHEN T0.[Status] = 'UNPUBLISHED' AND (SELECT COUNT(X.CC) FROM HelpdeskCc X WHERE X.AC = 'REQUESTING REVIEW' AND '${user}' IN (SELECT CASE WHEN LEN(item) = 4 THEN CONCAT(item, '-01') ELSE item END item FROM [dbo].[ufnSplt](T4.Mentions, ','))) > 0 THEN 'Y' WHEN T0.[Status] = 'PUBLISHED' AND CONCAT(T0.KEPADA, '-01') = '${user}' AND ((SELECT COUNT(X.LineNum) FROM HelpdeskDetails X WHERE X.Nomor = T0.Nomor AND ISNULL(X.PIC, '') = '') > 0 OR (SELECT COUNT(X.LineNum) FROM HelpdeskDetails X WHERE X.Nomor = T0.Nomor AND X.[Status] = 'WAITING') <= 0) THEN 'Y' WHEN T0.[Status] = 'PUBLISHED' AND (SELECT COUNT(X.LineNum) FROM HelpdeskDetails X WHERE X.Nomor = T0.Nomor AND ISNULL(X.PIC, '') = '${user}' AND X.[Status] = 'WAITING') > 0 THEN 'Y' ELSE 'N' END NamaFile, CASE WHEN T0.[Status] = 'PUBLISHED' THEN 0 WHEN T0.[Status] = 'UNPUBLISHED' THEN 1 ELSE 2 END FROM HelpdeskHeader T0 INNER JOIN HelpdeskDetails T1 ON T0.Nomor = T1.Nomor LEFT JOIN HelpdeskCc T2 ON T0.Nomor = T2.Nomor INNER JOIN HelpdeskBagian T3 ON T0.Kepada = T3.Code LEFT JOIN HelpdeskNote T4 ON T0.Nomor = T4.Nomor WHERE ${whereClause} ORDER BY ${orderClause}`);
    return helpdeskList.map(helpdesk => {
      const newHelpdesk = HelpdeskHeaderModel.createFromType(helpdesk);
      newHelpdesk.progress = newHelpdesk.pertimbangan;
      newHelpdesk.notified = newHelpdesk.namaFile === "Y";
      newHelpdesk.pertimbangan = newHelpdesk.namaFile = "";
      return newHelpdesk;
    });
  };

  // Method to retrive a single Helpdesk Header data together with its related value from dependent table (Helpdesk Details, CC, and Note)
  // using the "nomor" value as parameter.
  static async getHelpdeskByNumber(nomor: string) {
    const data = await prisma.helpdeskHeader.findFirstOrThrow({
      where: { Nomor: nomor },
      include: { HelpdeskDetails: { include: { HelpdeskNoteJobReg: true } }, HelpdeskCc: true, HelpdeskNote: true }
    })
    const helpdeskHeader = HelpdeskHeaderModel.createFromType(data);
    if (helpdeskHeader.namaFile.length > 0) {
      const filePath = path.join(__dirname, "../uploads/helpdesk/", helpdeskHeader.nomor, helpdeskHeader.namaFile);
      if (fs.existsSync(filePath)) {
        const fileBuffer = fs.readFileSync(filePath);
        helpdeskHeader.hashedFile = crypto.createHash("sha256").update(fileBuffer).digest("hex");
      }
    }

    // helpdeskHeader.detailsList.push(...data.HelpdeskDetails.map(details => HelpdeskDetailsModel.createFromType(details)));
    helpdeskHeader.detailsList.push(...data.HelpdeskDetails.map(details => {
      const newDetails = HelpdeskDetailsModel.createFromType(details);
      newDetails.noteList.push(...details.HelpdeskNoteJobReg.map(note => HelpdeskNoteJobRegModel.createFromType(note)));
      return newDetails;
    }));
    
    helpdeskHeader.ccList.push(...data.HelpdeskCc.map(ccData => {
      let hashedFile = "";
      if (ccData.NamaFile.length > 0) {
        const filePath = path.join(__dirname, "../uploads/helpdesk/", helpdeskHeader.nomor, ccData.NamaFile);
        if (fs.existsSync(filePath)) {
          const fileBuffer = fs.readFileSync(filePath);
          hashedFile = crypto.createHash("sha256").update(fileBuffer).digest("hex");
        }
      }
      const cc = HelpdeskCcModel.createFromType(ccData);
      cc.hashedFile = hashedFile;
      return cc;
    }));
    helpdeskHeader.noteList.push(...data.HelpdeskNote.map(note => HelpdeskNoteModel.createFromType(note)));
    return helpdeskHeader
  };

  // Method for creating new helpdesk data by using the current HelpdeskHeader object instance. This method accept
  // an optional parameter with type of database transaction from Prisma. It will use the transaction instance
  // to execute the operation if the parameter is provided or plain prisma instance with no transaction if isn't.
  insertHeader = async (tx?: Prisma.TransactionClient) => {
    const client = tx ?? prisma;
    return client.helpdeskHeader.create({
      data: this.createAsType()
    });
  };
  
  // Method for updating helpdesk data by using the current HelpdeskHeader object instance. This method accept
  // an optional parameter with type of database transaction from Prisma. It will use the transaction instance
  // to execute the operation if the parameter is provided or plain prisma instance with no transaction if isn't.
  updateHeader = async (tx?: Prisma.TransactionClient) => {
    const client = tx ?? prisma;
    return client.helpdeskHeader.update({
      where: { Nomor: this.nomor },
      data: this.createAsType()
    });
  };
}

export default HelpdeskHeaderModel;
